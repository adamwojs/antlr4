<?php

declare(strict_types=1);

namespace ANTLR\v4\Runtime\ATN;

use ANTLR\v4\Runtime\BaseObject;
use ANTLR\v4\Runtime\Exception\IllegalArgumentException;
use ANTLR\v4\Runtime\Misc\IntervalSet;
use ANTLR\v4\Runtime\RuleContext;
use ANTLR\v4\Runtime\Token;
use InvalidArgumentException;
use RuntimeException;

class ATN extends BaseObject
{
    /** @var int */
    public const INVALID_ALT_NUMBER = 0;

    /** @var \ANTLR\v4\Runtime\ATN\ATNState[] */
    public $states = [];

    /**
     * Each subrule/rule is a decision point and we must track them so we
     * can go back later and build DFA predictors for them. This includes
     * all the rules, subrules, optional blocks, ()+, ()* etc...
     *
     * @var \ANTLR\v4\Runtime\ATN\DecisionState[]
     */
    public $decisionToState = [];

    /**
     * Maps from rule index to starting state number.
     *
     * @var \ANTLR\v4\Runtime\ATN\RuleStartState[]
     */
    public $ruleToStartState;

    /**
     * Maps from rule index to stop state number.
     *
     * @var \ANTLR\v4\Runtime\ATN\RuleStopState[]
     */
    public $ruleToStopState;

    /**
     * @see \ANTLR\v4\Runtime\ATN\ATNType
     *
     * @var int
     */
    public $grammarType;

    /**
     * The maximum value for any symbol recognized by a transition in the ATN.
     *
     * @var int
     */
    public $maxTokenType;

    /**
     * For lexer ATNs, this maps the rule index to the resulting token type.
     * For parser ATNs, this maps the rule index to the generated bypass token
     * type if the
     * {@link ATNDeserializationOptions#isGenerateRuleBypassTransitions}
     * deserialization option was specified; otherwise, this is {@code null}.
     *
     * @var int[]
     */
    public $ruleToTokenType;

    /**
     * For lexer ATNs, this is an array of {@link LexerAction} objects which may
     * be referenced by action transitions in the ATN.
     *
     * @var \ANTLR\v4\Runtime\ATN\LexerAction[]
     */
    public $lexerActions;

    /**
     * @var \ANTLR\v4\Runtime\ATN\TokensStartState[]
     */
    public $modeToStartState;

    /**
     * @var array
     */
    public $modeNameToStartState;

    /**
     * Used for runtime deserialization of ATNs from strings.
     *
     * @param int $grammarType
     * @param int $maxTokenType
     */
    public function __construct(int $grammarType, int $maxTokenType)
    {
        $this->grammarType = $grammarType;
        $this->maxTokenType = $maxTokenType;
    }

    /**
     * Compute the set of valid tokens that can occur starting in state {@code s}.
     * If {@code ctx} is null, the set of tokens will not include what can follow
     * the rule surrounding {@code s}. In other words, the set will be
     * restricted to tokens reachable staying within {@code s}'s rule.
     *
     * @param \ANTLR\v4\Runtime\ATN\ATNState $state
     * @param \ANTLR\v4\Runtime\RuleContext|null $ctx
     *
     * @return \ANTLR\v4\Runtime\Misc\IntervalSet
     */
    public function nextTokensForATNStateAndRuleContext(ATNState $state, ?RuleContext $ctx = null): IntervalSet
    {
        return (new LL1Analyzer($this))->LOOK($state, null, $ctx);
    }

    /**
     * Compute the set of valid tokens that can occur starting in {@code s} and
     * staying in same rule. {@link Token#EPSILON} is in set if we reach end of
     * rule.
     *
     * @param \ANTLR\v4\Runtime\ATN\ATNState $state
     *
     * @return \ANTLR\v4\Runtime\Misc\IntervalSet
     */
    public function nextTokensForATNState(ATNState $state): IntervalSet
    {
        if ($state->nextTokenWithinRule !== null) {
            return $state->nextTokenWithinRule;
        }

        $state->nextTokenWithinRule = $this->nextTokensForATNStateAndRuleContext($state, null);
        $state->nextTokenWithinRule->setReadonly(true);

        return $state->nextTokenWithinRule;
    }

    public function addState(?ATNState $state): void
    {
        if ($state !== null) {
            $state->atn = $this;
            $state->stateNumber = count($this->states);
        }

        $this->states[] = $state;
    }

    public function removeState(ATNState $state): void
    {
        // Don't shift states in list
        $this->states[$state->stateNumber] = null;
    }

    public function defineDecisionState(DecisionState $state): int
    {
        $this->decisionToState[] = $state;
        $state->decision = count($this->decisionToState) - 1;

        return $state->decision;
    }

    public function getDecisionState(int $decision): ?DecisionState
    {
        if (!empty($this->decisionToState)) {
            return $this->decisionToState[$decision];
        }

        return null;
    }

    public function getNumberOfDecisions(): int
    {
        return count($this->decisionToState);
    }

    /**
     * Computes the set of input symbols which could follow ATN state number
     * {@code stateNumber} in the specified full {@code context}. This method
     * considers the complete parser context, but does not evaluate semantic
     * predicates (i.e. all predicates encountered during the calculation are
     * assumed true). If a path in the ATN exists from the starting state to the
     * {@link RuleStopState} of the outermost context without matching any
     * symbols, {@link Token#EOF} is added to the returned set.
     *
     * <p>If {@code context} is {@code null}, it is treated as {@link ParserRuleContext#EMPTY}.</p>
     *
     * Note that this does NOT give you the set of all tokens that could
     * appear at a given token position in the input phrase.  In other words,
     * it does not answer:
     *
     *   "Given a specific partial input phrase, return the set of all tokens
     *    that can follow the last token in the input phrase."
     *
     * The big difference is that with just the input, the parser could
     * land right in the middle of a lookahead decision. Getting
     * all *possible* tokens given a partial input stream is a separate
     * computation. See https://github.com/antlr/antlr4/issues/1428
     *
     * For this function, we are specifying an ATN state and call stack to compute
     * what token(s) can come next and specifically: outside of a lookahead decision.
     * That is what you want for error reporting and recovery upon parse error.
     *
     * @param int $stateNumber the ATN state number
     * @param \ANTLR\v4\Runtime\RuleContext $context the full parse context
     *
     * @return \ANTLR\v4\Runtime\Misc\IntervalSet the set of potentially valid input symbols which could follow the
     * specified state in the specified context
     *
     * @throws IllegalArgumentException if the ATN does not contain a state with
     * number {@code stateNumber}
     */
    public function getExpectedTokens(int $stateNumber, RuleContext $context): IntervalSet
    {
        if ($stateNumber < 0 || $stateNumber >= count($this->states)) {
            throw new InvalidArgumentException('Invalid state number');
        }

        $following = $this->nextTokensForATNState($this->states[$stateNumber]);
        if (!$following->contains(Token::EPSILON)) {
            return $following;
        }

        $expected = new IntervalSet();
        $expected->addAll($following);
        $expected->remove(Token::EPSILON);

        $ctx = $context;
        while ($ctx !== null && $ctx->invokingState >= 0 && $following->contains(Token::EPSILON)) {
            $rt = $this->states[$ctx->invokingState]->transition(0);
            if (!($rt instanceof RuleTransition)) {
                throw new RuntimeException('Expected $rt to be instance of RuleTransition');
            }

            $following = $this->nextTokensForATNState($rt->followState);
            $expected->addAll($following);
            $expected->remove(Token::EPSILON);

            $ctx = $ctx->parent;
        }

        if ($following->contains(Token::EPSILON)) {
            $expected->add(Token::EOF);
        }

        return $expected;
    }
}
